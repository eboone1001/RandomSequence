import getopt
import random as rand
import sys

# Global varables
# Default alphabets
default_DNA = {base: .25 for base in "ATGC"}
default_AA = {aa: .05 for aa in "ACDEFGHIKLMNPQRSTVWY"}
default_BINARY = {bit: .5 for bit in "10"}


class RandomGenerator:
    alphabet = {}
    # TODO: count how many times each character is included. Useful for diagnostic
    counts = []

    def __init__(self, alphabet_dict=None):
        """
        Constructor for Random generator object. All it needs is a dictionary in the format {character:frequency}.
        Not really meant for use by user.
        :param alphabet_dict:
        """
        # No matter what dictionary is passed in, normalize it.
        self.alphabet = RandomGenerator._normalize_alphabet(alphabet_dict)
        counts = [0] * len(alphabet_dict)

    def _generate_multiple_sequence(self,length, num_sequences):
        """
        Generates a single sequence multiple times and returns a list of seq. generated.
        """
        sequences = []
        for i in range(0, num_sequences):
            sequences.append(self._generate_single_sequence(length))

        return sequences

    # Functions for generating sequences
    def _generate_single_sequence(self, length):
        """
        Generate a single string of length n using the dictionary provided by the user.
        """
        sequence = ""

        for i in range(0,length):
            random_val = rand.random()
            sequence += self._pick_character(random_val)

        return sequence

    def _pick_character(self, random_val):
        """
        This function iterates though the dictionary of characters and frequencies, summing the freqs
        as they appear. The probability that on any loop, random_val < freq_sum[i] is equal to the probability
        that freq_sum[i-1] < random_val < freq_sum[i] = freq of the character in question. As a result, the sequence
        generator is alphabet and frequency agnostic.
        """
        probability_threshold = 0
        for char, freq in self.alphabet.items():
            probability_threshold += freq
            if random_val < probability_threshold:

                return char


    @staticmethod
    def _get_alphabet_from_file(filepath):
        """
        Reads in a file to create a dictionary compatible with the RandomGenerator object. Keeps a count
        of all values passed through it: this allows for input file to have entries of char:count or char:freq,
        as counts will be converted to freq, and frequencies will be divided by 1.
        TODO: Consider adding a warning message to let the user know if they get a float total_count, in case of input mistake
        :param filepath:
        :param sep:
        :return: alphabet dictionary
        """

        input_file = open(filepath, "r")
        rows = input_file.readlines()
        input_file.close()

        alphabet = {}

        for row in rows:
            values = row.split()
            char = str(values[0])
            freq = float(values[1])
            alphabet[char] = freq

        return alphabet

    @staticmethod
    def _normalize_alphabet(dict):
        """
        Given a character:frequency dictionary, this normalizes frequencies. As a result, the user can pass in counts
        data in the frequency position, and this will generate freqencies based on character counts/total counts.
        # TODO: some sort of warning if it is likely that the user meant to use frquencies, but the total counts =/= 1}
        :param dict:
        :return: normalized dictionary
        """
        total_count = 0
        for char, freq in dict.items():
            total_count += freq

        normalized_dictionary = {}
        for char, freq in dict.items():
            normalized_dictionary[char] = freq/total_count

        return normalized_dictionary

def generate_sequence(length_x_number, alphabet_dict=None, filepath=None, default_mode=None):
    """
    This is the function that is meant to be called by users.
    :param length_x_number: tuple where first digit represents length of each seqence and second represents
    number of sequences.
    :param alphabet_dict: character:frequency dictionary object
    :param filepath: path to character:frequency dictionary like file
    :param default_mode: pick a default character:frequency dictionary from 'dna', 'aa','protein',
    'binary' ('protein' and 'aa' are identical)
    :return: the list of sequences generated by the function.
    """
    # Check to see if there is any proper input
    if filepath is None and default_mode is None and alphabet_dict is None:
        raise IOError("function requires at least one of the following: dictionary object, filepath, "
                      "or string name of preferred default.")

    # assignment of alphabet dictionary. Priority is explicitly provided dictionary, then file path, then default
    # configuration.
    if alphabet_dict is not None:
        alphabet = alphabet_dict
    elif filepath is not None:
        alphabet = RandomGenerator._get_alphabet_from_file(filepath)
    elif default_mode is not None:
        default_mode = default_mode.lower()
        if default_mode in "dna":
            alphabet = default_DNA
        elif default_mode in ["aa", "protein"]:
            alphabet = default_AA
        elif default_mode in "binary":
            alphabet = default_BINARY
        else:
            raise IOError("Choose a default from the following list: 'dna', 'aa','protein', 'binary'")

    # create the generator object and generate sequences.from
    # TODO: if we would be returning a single member list, return a string instead
    generator_object = RandomGenerator(alphabet)
    return generator_object._generate_multiple_sequence(length_x_number[0], length_x_number[1])


# For testing
if __name__ == "__main__":

    # ----- This chunk of code is for processing command line arguments ---------------------------
    filepath = ""
    preset = ""

    argumentList = sys.argv[1:]
    options = "f:p:"
    try:
        arguments, values = getopt.getopt(argumentList, options)

        num_chars = int(argumentList[0])
        num_lines = int(argumentList[1])

        for currArg, currVal in arguments:
            if currArg in "-f":
                print("Input file: " + currVal)
                filepath = currVal

            elif currArg in "-p":
                print("Using Preset: " + currVal)
                preset = currVal

    except getopt.error as err:
        print("Command failed...USAGE: ")
        print("python RandomGenerator.py (# of Chars/Line) (# of lines) (-f <dict file> OR -p <preset>)")
    # -------- Command line processing complete ---------------------------------------------------

    if preset != "":
        print(generate_sequence((10, 5), default_mode=preset))

    elif filepath != "":
        print(generate_sequence((10, 5), filepath=filepath))

    